import pandas as pd
import numpy as np
import time
from tabulate import tabulate
import scipy.optimize as optimize
import datetime
import time
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st

class Markowitz(object):

    def __init__(self, df, assets, iterations, min_value, risk_free_rate=0.2):
        self.df = df
        self.assets = assets
        self.n_assets = len(self.assets)
        self.iterations = iterations
        self.min_value = min_value
        self.risk_free_rate = risk_free_rate

    def rand_weights(self, n):
        ''' Produces n random weights that sum to 1 '''
        k = np.random.rand(n)
        return k / sum(k)


    def portfolio_simulation(self):
        '''
        Runs a simulation by randomly selecting portfolio weights a specified
        number of times (iterations), returns the list of results and plots 
        all the portfolios as well.
        
        Parameters:
        -----------  
            assets: list
                all the assets that are to be pulled from Quandl to comprise
                our portfolio.    
            iterations: int 
                the number of randomly generated portfolios to build.
        
        Returns:
        --------
            port_returns: array
                array of all the simulated portfolio returns.
            port_vols: array
                array of all the simulated portfolio volatilities.
        '''
        start = time.time()
        
        # Getting returns
        returns = self.df.pct_change()
        
        port_returns = []
        port_vols = []
        
        for i in range (self.iterations):
            # Generating random weights using dirichlet distribution
            weights = self.rand_weights(self.n_assets)
            
            # Returns: R = pt.w
            port_return = np.sum(returns.mean() * weights) * 252
            port_returns.append(port_return)
            
            # Volatility: sigma = sqrt( wt.C.w )
            port_vol = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
            port_vols.append(port_vol)
        
        # Convert lists to arrays
        port_returns = np.array(port_returns)
        port_vols = np.array(port_vols)
    
        return port_returns, port_vols

    def get_portfolio_stats(self, weights):
        '''
        We can gather the portfolio performance metrics for a specific set of weights.
        This function will be important because we'll want to pass it to an optmization
        function to get the portfolio with the best desired characteristics.
        
        Note: Sharpe ratio here uses a risk-free short rate of 0.
        
        Paramaters: 
        -----------
            weights: array, 
                asset weights in the portfolio.
            returns: dataframe
                a dataframe of returns for each asset in the trial portfolio    
        
        Returns: 
        --------
            dict of portfolio statistics - mean return, volatility, sharp ratio.
        '''
        # random weights generated by optimization function
        weights = np.array(weights)
        
        # Returns: R = pt.w
        returns = self.df.pct_change()
        port_return = np.sum(returns.mean() * weights) * 252
        
        # Volatility: sigma = sqrt( wt.C.w )
        port_vol = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
        
        # Sharpe ratio
        sharpe = (port_return - self.risk_free_rate)/port_vol

        return {'return': port_return, 'volatility': port_vol, 'sharpe': sharpe}

    def minimize_sharpe(self, weights):  
        return -self.get_portfolio_stats(weights)['sharpe'] 

    def minimize_volatility(self, weights):  
        return self.get_portfolio_stats(weights)['volatility'] 

    def maximize_return(self, weights): 
        return -self.get_portfolio_stats(weights)['return']

    def portfolio_optimization(self, func_to_optimize, constraints, bounds, initializer):
    
        # Optimizing for given function
        optimal_result = optimize.minimize(
            fun = func_to_optimize,
            x0 = initializer,
            method = 'SLSQP',
            bounds = bounds,
            constraints = constraints
        )
        
        # Getting optimal weights for each asset
        optimal_weights = optimal_result['x'].round(4)
        
        # Getting optimal portfolio stats
        optimal_stats = self.get_portfolio_stats(optimal_weights)
        
        return optimal_weights, optimal_stats

    def plot_efficient_frontier(self):

        # Initializing parameters for optimization
        constraints = ({'type' : 'eq', 'fun': lambda x: np.sum(x) -1})
        bounds = tuple((self.min_value, 1) for x in range(self.n_assets))
        initializer = self.n_assets * [1./self.n_assets,]

        # Optimizing to efficient frontier
        weights_sharpe, stats_sharpe = self.portfolio_optimization(self.minimize_sharpe, constraints, bounds, initializer)
        weights_return, stats_return = self.portfolio_optimization(self.maximize_return, constraints, bounds, initializer)
        weights_risk, stats_risk = self.portfolio_optimization(self.minimize_volatility, constraints, bounds, initializer)

        sharpe_dict = {**dict(zip(self.assets, weights_sharpe)), **stats_sharpe}
        return_dict = {**dict(zip(self.assets, weights_return)), **stats_return}
        risk_dict = {**dict(zip(self.assets, weights_risk)), **stats_risk}

        max_sharpe = pd.DataFrame(sharpe_dict, index=["Max Sharpe"])
        max_return = pd.DataFrame(return_dict, index=["Max Return"])
        min_risk = pd.DataFrame(risk_dict, index=["Min Volatility"])

        final_df = pd.concat([max_sharpe, max_return, min_risk], axis=0)
        for stats in ["return", "volatility"]:
            final_df[stats] = final_df[stats].apply(lambda x: round(100*x, 4))

        # Getting simulated portfolios
        port_returns, port_vols = self.portfolio_simulation()

        # Make an array of 50 returns betweeb the minimum return and maximum return
        # discovered earlier.
        target_returns = np.linspace(port_returns.min(), port_returns.max(),50)

        # Initialize optimization parameters
        minimal_volatilities = []
        bounds = tuple((self.min_value, 1) for x in range(self.n_assets))
        initializer = self.n_assets * [1./self.n_assets,]

        for target_return in target_returns:
            
            constraints = (
                {'type':'eq','fun': lambda x: self.get_portfolio_stats(x)['return'] - target_return},
                {'type':'eq','fun': lambda x: np.sum(x)-1}
            )
            
            optimal = optimize.minimize(
                self.minimize_volatility,
                initializer,
                method = 'SLSQP',
                bounds = bounds,
                constraints = constraints
            )
            
            minimal_volatilities.append(optimal['fun'])

        minimal_volatilities = np.array(minimal_volatilities)

        # Plotting efficient frontier
        fig = go.Figure(
            go.Scatter(
                x = port_vols,
                y = port_returns,
                mode = 'markers',
                marker_color = (port_returns / port_vols),
                marker = dict(colorscale='Viridis', showscale=True),
                name = "Simulated Portfolios"
            )
        )

        fig.add_trace(
            go.Scatter(
                x = minimal_volatilities,
                y = target_returns,
                mode = 'lines',
                marker_color = "red",
                line = dict(dash = 'dash'),
                name = "Efficient Frontier"
            )
        )

        fig.add_trace(
            go.Scatter(
                x = [stats_sharpe['volatility']],
                y = [stats_sharpe['return']],
                mode = 'markers',
                marker_color = "red",
                marker = dict(size=16, symbol = "hexagram", showscale=False),
                name = "Maximum Sharpe Ratio",
            )
        )

        fig.add_trace(
            go.Scatter(
                x = [stats_risk['volatility']],
                y = [stats_risk['return']],
                mode = 'markers',
                marker_color = "green",
                marker = dict(size=16, symbol = "hexagram", showscale=False),
                name = "Minimum Volatility",
            )
        )
        fig.update_layout(
            xaxis_title = "Volatility",
            yaxis_title = "Return",
            width=800,
            height=600,
            legend_orientation="h"
        )

        return final_df, fig
        
    